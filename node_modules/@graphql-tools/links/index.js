'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

const core = require('@apollo/client/link/core');
const apolloUploadClient = require('apollo-upload-client');
const FormData = _interopDefault(require('form-data'));
const fetch = _interopDefault(require('node-fetch'));
const utilities = require('@apollo/client/utilities');
const core$1 = require('@apollo/client/core');
const utils = require('@graphql-tools/utils');
const graphql = require('graphql');

function getFinalPromise(object) {
    return Promise.resolve(object).then(resolvedObject => {
        if (resolvedObject == null) {
            return resolvedObject;
        }
        if (Array.isArray(resolvedObject)) {
            return Promise.all(resolvedObject.map(o => getFinalPromise(o)));
        }
        else if (typeof resolvedObject === 'object') {
            const keys = Object.keys(resolvedObject);
            return Promise.all(keys.map(key => getFinalPromise(resolvedObject[key]))).then(awaitedValues => {
                for (let i = 0; i < keys.length; i++) {
                    resolvedObject[keys[i]] = awaitedValues[i];
                }
                return resolvedObject;
            });
        }
        return resolvedObject;
    });
}
class AwaitVariablesLink extends core.ApolloLink {
    request(operation, forward) {
        return new utilities.Observable(observer => {
            let subscription;
            getFinalPromise(operation.variables)
                .then(resolvedVariables => {
                operation.variables = resolvedVariables;
                subscription = forward(operation).subscribe({
                    next: observer.next.bind(observer),
                    error: observer.error.bind(observer),
                    complete: observer.complete.bind(observer),
                });
            })
                .catch(observer.error.bind(observer));
            return () => {
                if (subscription != null) {
                    subscription.unsubscribe();
                }
            };
        });
    }
}

const createServerHttpLink = (options) => core.concat(new AwaitVariablesLink(), apolloUploadClient.createUploadLink({
    ...options,
    fetch,
    FormData,
    isExtractableFile: (value) => apolloUploadClient.isExtractableFile(value) || (value === null || value === void 0 ? void 0 : value.createReadStream),
    formDataAppendFile: (form, index, file) => {
        if (file.createReadStream != null) {
            form.append(index, file.createReadStream(), {
                filename: file.filename,
                contentType: file.mimetype,
            });
        }
        else {
            apolloUploadClient.formDataAppendFile(form, index, file);
        }
    },
}));

function linkToExecutor(link) {
    return function executorFromLink(request) {
        const observable = core.execute(link, {
            query: request.document,
            operationName: request.operationName,
            variables: request.variables,
            context: {
                graphqlContext: request.context,
                graphqlResolveInfo: request.info,
                clientAwareness: {},
            },
            extensions: request.extensions,
        });
        const operationAst = utils.getOperationASTFromRequest(request);
        if (operationAst.operation === 'subscription') {
            return utils.observableToAsyncIterable(observable);
        }
        return core$1.toPromise(observable);
    };
}

const GraphQLUpload = new graphql.GraphQLScalarType({
    name: 'Upload',
    description: 'The `Upload` scalar type represents a file upload.',
    parseValue: (value) => {
        if (value != null && 'promise' in value) {
            // graphql-upload v10
            return value.promise;
        }
        else {
            // graphql-upload v9
            return value;
        }
    },
    // serialization requires to support schema stitching
    serialize: value => value,
    parseLiteral: ast => {
        throw new graphql.GraphQLError('Upload literal unsupported.', ast);
    },
});

exports.AwaitVariablesLink = AwaitVariablesLink;
exports.GraphQLUpload = GraphQLUpload;
exports.createServerHttpLink = createServerHttpLink;
exports.linkToExecutor = linkToExecutor;
